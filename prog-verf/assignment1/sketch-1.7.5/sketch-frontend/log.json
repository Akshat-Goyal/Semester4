{"1584428844.194258": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(!lst.head){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert n == null || pos < 0;\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp == null;\n\tint i;\n\tfor(i = 0; tmp.next && i < pos - 1; i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert i == (pos - 1);\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val = 70;\n}", "problem_number": 2}, "1584430637.5276625": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; {| tmp(.next)? |} != null && i < (pos - ??); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430431.5513902": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| tmp(.next)? |});\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584429342.3629127": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(!lst.head){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\t//assert (!n || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\t//assert !tmp;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\t//assert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584426098.6424835": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum = ??;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\t\t\tint tmp = a[i, k] * b[k, j];\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t{| sum | tmp |} = {| tmp | sum*tmp | sum+tmp |}\n\t\t\t\tsum += a[i, k] * b[k, j];\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584430451.2743108": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430484.1095502": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\t{| tmp | tmp.next |} = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584428936.7887475": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\t/* if(!lst.head){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n; */\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\t/* assert n == null || pos < 0;\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp == null;\n\tint i;\n\tfor(i = 0; tmp.next && i < pos - 1; i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert i == (pos - 1);\n\tn.next = tmp.next;\n\ttmp.next = n; */\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val = 70;\n}", "problem_number": 2}, "1584429362.9095454": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\t//assert (!n || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\t//assert !tmp;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\t//assert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430880.3656845": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; {| tmp{.next} |} != null && i < (pos - ??); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\tNode n2 = new Node(next = null, val = 40);\n  \tNode n3 = new Node(next = null, val = 34);\n\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n\tassert l2.head.next.next.val == 60;\n\tList l3 = insertAt(l, n2, 0);\n  \tassert l3.head.val==40;\n  \tassert l3.head.next.val==5;\n  \tList l4 = insertAt(l,n3, 4);\n  \tassert l4.head.next.next.next.next.val == 34;  \n}", "problem_number": 2}, "1584426173.0769649": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum = 0;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tint tmp = a[i, k] * b[k, j];\n\t\t\t\tsum = {| tmp | (sum*tmp) | (sum+tmp) |}\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584429303.1408381": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(!lst.head){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\t//assert (!n || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\t//assert !tmp;\n\tint i;\n\tfor(i = 0; tmp.next && i < pos - 1; i++){\n\t\ttmp = tmp.next;\n\t}\n\t//assert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430989.4012282": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - ??); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = {| tmp(.next)? |};\n\ttmp.next = {| n(.next)? |};\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\tNode n2 = new Node(next = null, val = 40);\n  \tNode n3 = new Node(next = null, val = 34);\n\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n\tassert l2.head.next.next.val == 60;\n\tList l3 = insertAt(l, n2, 0);\n  \tassert l3.head.val==40;\n  \tassert l3.head.next.val==5;\n  \tList l4 = insertAt(l,n3, 4);\n  \tassert l4.head.next.next.next.next.val == 34;  \n}", "problem_number": 2}, "1584430897.2733338": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; {| tmp(.next)? |} != null && i < (pos - ??); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\tNode n2 = new Node(next = null, val = 40);\n  \tNode n3 = new Node(next = null, val = 34);\n\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n\tassert l2.head.next.next.val == 60;\n\tList l3 = insertAt(l, n2, 0);\n  \tassert l3.head.val==40;\n  \tassert l3.head.next.val==5;\n  \tList l4 = insertAt(l,n3, 4);\n  \tassert l4.head.next.next.next.next.val == 34;  \n}", "problem_number": 2}, "1584426321.6422267": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\t\t\tsum = ??;\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tint tmp = a[i, k] * b[k, j];\n\t\t\t\tsum = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584429412.9166157": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\t//assert !tmp;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\t//assert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584426558.4813225": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tint tmp = {| (a[i, k] * b[k, j]) | (a[i, k] + b[k, j]) |};\n\n\t\t\t\t// tmp can be added to sum or multiplied to sum or equal to sum\n\t\t\t\tsum = {| tmp | (sum*tmp) | (sum+tmp) |};\n\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584430663.1512437": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584431082.4536254": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum, tmp;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\ttmp = a[i, k] * b[k, j];\n\n\t\t\t\t// sum or tmp can be used here\n\t\t\t\t// tmp can be added to sum or multiplied to sum or assigned to sum\n\t\t\t\t{| tmp | sum |} = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584426817.4907274": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tint tmp = a[i, k] * b[k, j];\n\n\t\t\t\t// tmp can be added to sum or multiplied to sum or equal to sum\n\t\t\t\t{| tmp | sum |} = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584430504.6857336": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\t{| (tmp)(.next)? |} = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584426116.7824285": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum = ??;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\t\t\tint tmp = a[i, k] * b[k, j];\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tsum = {| tmp | sum*tmp | sum+tmp |}\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584426883.6999822": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum, tmp;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\ttmp = a[i, k] * b[k, j];\n\n\t\t\t\t// sum or tmp can be used \n\t\t\t\t// tmp can be added to sum or multiplied to sum or equal to sum\n\t\t\t\t{| tmp | sum |} = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584431046.803692": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\n\t// i < pos or i < pos - 1\n\tfor(i = 0; tmp.next != null && i < (pos - ??); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\n\t// n.next = tmp or tmp.next\n\tn.next = {| tmp(.next)? |};\n\n\t// tmp.next = n or n.next\n\ttmp.next = {| n(.next)? |};\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\tNode n2 = new Node(next = null, val = 40);\n  \tNode n3 = new Node(next = null, val = 34);\n\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n\tassert l2.head.next.next.val == 60;\n\tList l3 = insertAt(l, n2, 0);\n  \tassert l3.head.val==40;\n  \tassert l3.head.next.val==5;\n  \tList l4 = insertAt(l,n3, 4);\n  \tassert l4.head.next.next.next.next.val == 34;  \n}", "problem_number": 2}, "1584430223.0477498": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; {| (tmp)(.next)? |} != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584426755.0010974": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tint tmp = a[i, k] * b[k, j];\n\n\t\t\t\t// tmp can be added to sum or multiplied to sum or equal to sum\n\t\t\t\tsum = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584430325.407287": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; {| (tmp)(.next) |} != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584385215.0776575": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  \tassert P == N;\n\tint sum = 0;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tsum += a[i, k] * b[k, j];\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584430841.7936554": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - ??); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\tNode n2 = new Node(next = null, val = 40);\n  \tNode n3 = new Node(next = null, val = 34);\n\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n\tassert l2.head.next.next.val == 60;\n\tList l3 = insertAt(l, n2, 0);\n  \tassert l3.head.val==40;\n  \tassert l3.head.next.val==5;\n  \tList l4 = insertAt(l,n3, 4);\n  \tassert l4.head.next.next.next.next.val == 34;  \n}", "problem_number": 2}, "1584426590.02345": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tint tmp = a[i, k] * b[k, j];\n\t\t\t\t// int tmp = {| (a[i, k] * b[k, j]) | (a[i, k] + b[k, j]) |};\n\t\t\t\t// tmp can be added to sum or multiplied to sum or equal to sum\n\t\t\t\tsum = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584429737.1374164": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584426615.2344046": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t// int tmp = a[i, k] * b[k, j];\n\t\t\t\tint tmp = {| (a[i, k]*b[k, j]) | (a[i, k]+b[k, j]) |};\n\t\t\t\t// tmp can be added to sum or multiplied to sum or equal to sum\n\t\t\t\tsum = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584430378.9710164": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584429053.490238": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(!lst.head){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\t// assert n == null || pos < 0;\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\t// assert tmp == null;\n\tint i;\n\tfor(i = 0; tmp.next && i < pos - 1; i++){\n\t\ttmp = tmp.next;\n\t}\n\t// assert i == (pos - 1);\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584431087.2133126": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\n\t// i < pos or i < pos - 1\n\tfor(i = 0; tmp.next != null && i < (pos - ??); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\n\t// n.next = tmp or tmp.next\n\tn.next = {| tmp(.next)? |};\n\n\t// tmp.next = n or n.next\n\ttmp.next = {| n(.next)? |};\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\tNode n2 = new Node(next = null, val = 40);\n  \tNode n3 = new Node(next = null, val = 34);\n\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n\tassert l2.head.next.next.val == 60;\n\tList l3 = insertAt(l, n2, 0);\n  \tassert l3.head.val==40;\n  \tassert l3.head.next.val==5;\n  \tList l4 = insertAt(l,n3, 4);\n  \tassert l4.head.next.next.next.next.val == 34;  \n}", "problem_number": 2}, "1584429224.3614466": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(!lst.head){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert (!n || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert !tmp;\n\tint i;\n\tfor(i = 0; tmp.next && i < pos - 1; i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584442692.2812777": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum, tmp;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\ttmp = a[i, k] * b[k, j];\n\n\t\t\t\t// sum or tmp can be used here\n\t\t\t\t// tmp can be added to sum or multiplied to sum or assigned to sum\n\t\t\t\t{| tmp | sum |} = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584429863.9131944": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; {| (tmp)(.next)? |} != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584429428.7014403": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\t//assert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584428983.2596204": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\t/* if(!lst.head){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n; */\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\t/* assert n == null || pos < 0;\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp == null;\n\tint i;\n\tfor(i = 0; tmp.next && i < pos - 1; i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert i == (pos - 1);\n\tn.next = tmp.next;\n\ttmp.next = n; */\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430055.9714158": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\t/*if(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}*/\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\t//assert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430070.5469203": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\t/*if(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}*/\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584429568.8271537": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430570.5487707": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\t\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584429380.382359": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\t//assert (!n || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\t//assert !tmp;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\t//assert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430925.2413695": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - ??); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\tNode n2 = new Node(next = null, val = 40);\n  \tNode n3 = new Node(next = null, val = 34);\n\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n\tassert l2.head.next.next.val == 60;\n\tList l3 = insertAt(l, n2, 0);\n  \tassert l3.head.val==40;\n  \tassert l3.head.next.val==5;\n  \tList l4 = insertAt(l,n3, 4);\n  \tassert l4.head.next.next.next.next.val == 34;  \n}", "problem_number": 2}, "1584430359.6671965": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; {| tmp(.next)? |} != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430698.7918549": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - ??); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430044.522742": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\t/*if(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}*/\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\t//assert l1.head.next.next.val == 40;\n\t//assert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584425662.854992": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum = 0;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tsum += a[i, k] * b[k, j];\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584429965.6837358": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tprintf(\"hkj\");\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584429978.1714442": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584429003.917378": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(!lst.head){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert n == null || pos < 0;\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp == null;\n\tint i;\n\tfor(i = 0; tmp.next && i < pos - 1; i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert i == (pos - 1);\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584425609.6198695": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) implements product{\n  // your code here\n  \tassert P == N;\n\tint sum = 0;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tsum += a[i, k] * b[k, j];\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584430131.2802413": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n == null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp == null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584384978.7712202": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584437630.1485076": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\n\t// i < pos or i < pos - 1\n\tfor(i = 0; tmp.next != null && i < (pos - ??); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\n\t// n.next = tmp or tmp.next\n\tn.next = {| tmp(.next)? |};\n\n\t// tmp.next = n or n.next\n\ttmp.next = {| n(.next)? |};\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\tNode n2 = new Node(next = null, val = 40);\n  \tNode n3 = new Node(next = null, val = 34);\n\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n\tassert l2.head.next.next.val == 60;\n\tList l3 = insertAt(l, n2, 0);\n  \tassert l3.head.val==40;\n  \tassert l3.head.next.val==5;\n  \tList l4 = insertAt(l,n3, 4);\n  \tassert l4.head.next.next.next.next.val == 34;  \n}", "problem_number": 2}, "1584437624.8101249": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum, tmp;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\ttmp = a[i, k] * b[k, j];\n\n\t\t\t\t// sum or tmp can be used here\n\t\t\t\t// tmp can be added to sum or multiplied to sum or assigned to sum\n\t\t\t\t{| tmp | sum |} = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584425647.4096527": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) implements product{\n  // your code here\n  \tassert P == N;\n\tint sum = 0;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tsum += a[i, k] * b[k, j];\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584430093.0662408": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584426036.879963": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum = ??;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\t\t\tint tmp = 0;\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t{| sum | tmp |} = {| tmp | sum*tmp | sum+tmp |}\n\t\t\t\tsum += a[i, k] * b[k, j];\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584426126.1085784": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum = 0;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\t\t\tint tmp = a[i, k] * b[k, j];\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tsum = {| tmp | sum*tmp | sum+tmp |}\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584429994.99386": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\t//assert l1.head.next.next.val == 40;\n\t//assert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584426276.621908": {"source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum = 0;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\tint tmp = a[i, k] * b[k, j];\n\t\t\t\tsum = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\n\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n", "problem_number": 1}, "1584429641.396603": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430193.4784243": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = tmp.next);\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584429517.507335": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head != null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null || pos < 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - 1); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = tmp.next;\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n}", "problem_number": 2}, "1584430963.11165": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(lst.head == null){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next != null; tmp = {| (tmp)(.next)? |});\n\n\t// tmp or tmp.next equals n\n\t{| (tmp)(.next)? |} = n;\n\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\tassert ( n != null && pos >= 0);\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp != null;\n\tint i;\n\tfor(i = 0; tmp.next != null && i < (pos - ??); i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert (i == (pos - 1));\n\tn.next = {| tmp(.next)? |};\n\ttmp.next = n;\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n\tassert l1.head.next.next.next == null;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\tNode n2 = new Node(next = null, val = 40);\n  \tNode n3 = new Node(next = null, val = 34);\n\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val == 70;\n\tassert l2.head.next.next.val == 60;\n\tList l3 = insertAt(l, n2, 0);\n  \tassert l3.head.val==40;\n  \tassert l3.head.next.val==5;\n  \tList l4 = insertAt(l,n3, 4);\n  \tassert l4.head.next.next.next.next.val == 34;  \n}", "problem_number": 2}, "1584428870.7447937": {"source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n\tNode next;\n\tint val;\n}\n\nstruct List{\n\tNode head;\n}\n\nList append(List lst, Node n) {\n\tif(!lst.head){\n\t\tlst.head = n;\n\t\treturn lst;\n\t}\n\tNode tmp;\n\tfor(tmp = lst.head; tmp.next; ){\n\t\ttmp = tmp.next;\n\t}\n\ttmp.next = n;\n\treturn lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n\t/* assert n == null || pos < 0;\n\tNode tmp = lst.head;\n\tif(pos == 0){\n\t\tlst.head = n;\n\t\tn.next = tmp;\n\t\treturn lst;\n\t}\n\tassert tmp == null;\n\tint i;\n\tfor(i = 0; tmp.next && i < pos - 1; i++){\n\t\ttmp = tmp.next;\n\t}\n\tassert i == (pos - 1);\n\tn.next = tmp.next;\n\ttmp.next = n; */\n\treturn lst;\n}\n\n\n\nList populate(List l) {\n\t// this function adds a few nodes to an empty list.  This is used\n\t// for providing input-output examples.\n\t// returns: 5 -> 60\n\tNode n2 = new Node(next = null, val = 60);\n\tNode n1 = new Node(next = n2, val = 5);\n\tl.head = n1;\n\treturn l;\n}\n\n\nharness void testAppend(){\n\tList l = new List();\n\tl = populate(l);\n\t\n\t// assert for append\n\tNode n1 = new Node(next = null, val = 40);\n\tList l1 = append(l, n1);\n\tassert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n\tList l = new List();\n\tl = populate(l);\n\n\tNode n1 = new Node(next = null, val = 70);\n\t// assert for insertAt\n\tList l2 = insertAt(l, n1, 1);\n\tassert l2.head.next.val = 70;\n}", "problem_number": 2}, "1584983091.6992571": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum, tmp;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\ttmp = a[i, k] * b[k, j];\n\n\t\t\t\t// sum or tmp can be used here\n\t\t\t\t// tmp can be added to sum or multiplied to sum or assigned to sum\n\t\t\t\t{| tmp | sum |} = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584984372.8685336": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum, tmp;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\ttmp = a[i, k] * b[k, j];\n\n\t\t\t\t// sum or tmp can be used here\n\t\t\t\t// tmp can be added to sum or multiplied to sum or assigned to sum\n\t\t\t\t{| tmp | sum |} = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584984504.913014": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum, tmp;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\ttmp = a[i, k] * b[k, j];\n\n\t\t\t\t// sum or tmp can be used here\n\t\t\t\t// tmp can be added to sum or multiplied to sum or assigned to sum\n\t\t\t\t{| tmp | sum |} = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584984527.728396": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum, tmp;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\ttmp = a[i, k] * b[k, j];\n\n\t\t\t\t// sum or tmp can be used here\n\t\t\t\t// tmp can be added to sum or multiplied to sum or assigned to sum\n\t\t\t\t{| tmp | sum |} = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584985041.7345269": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n\t   assert P == N;\n\t   int sum = 0;\n\t   int[M][N] prod;\n\t   for (int i = 0; i < M; i++) {\n\t   \t   for (int j = 0; j < Q; j++) {\n\t\t   sum = 0;\n\t\t   for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t\t   prod[i][j] = sum;\n\t   }\n\t   }\n\t   return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b){\n  // your code here\n  \tassert P == N;\n\tint sum, tmp;\n\tint[M][N] prod;\n\tfor (int i = 0; i < M; i++) {\n\t   \tfor (int j = 0; j < Q; j++) {\n\n\t\t\t// sum can be initialized with 1 or 0\n\t\t\tsum = ??;\n\n\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\ttmp = a[i, k] * b[k, j];\n\n\t\t\t\t// sum or tmp can be used here\n\t\t\t\t// tmp can be added to sum or multiplied to sum or assigned to sum\n\t\t\t\t{| tmp | sum |} = {| tmp | (sum*tmp) | (sum+tmp) |};\n\t\t\t\t\n\t\t\t}\n\t\t\tprod[i][j] = sum;\n\t\t}\n\t}\n\treturn prod;\n}\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}}