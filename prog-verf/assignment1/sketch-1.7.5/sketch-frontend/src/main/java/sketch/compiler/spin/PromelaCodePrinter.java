/**
 *
 */
package sketch.compiler.spin;

import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.List;

import sketch.compiler.ast.core.FENode;
import sketch.compiler.ast.core.FieldDecl;
import sketch.compiler.ast.core.Function;
import sketch.compiler.ast.core.Function.FcnType;
import sketch.compiler.ast.core.Package;
import sketch.compiler.ast.core.Parameter;
import sketch.compiler.ast.core.SymbolTable;
import sketch.compiler.ast.core.exprs.ExprFunCall;
import sketch.compiler.ast.core.exprs.ExprTernary;
import sketch.compiler.ast.core.exprs.ExprTypeCast;
import sketch.compiler.ast.core.exprs.Expression;
import sketch.compiler.ast.core.stmts.*;
import sketch.compiler.ast.core.typs.StructDef;
import sketch.compiler.ast.core.typs.Type;
import sketch.compiler.ast.core.typs.TypeArray;
import sketch.compiler.ast.core.typs.TypePrimitive;
import sketch.compiler.ast.promela.stmts.StmtJoin;
import sketch.compiler.passes.lowering.AddLastAssignmentToFork;
import sketch.compiler.passes.printers.CodePrinterVisitor;

/**
 * @author Chris Jones
 */
public class PromelaCodePrinter extends CodePrinterVisitor {
	public static final String atomicCondLbl = "_atomicCondLbl";

	protected boolean sawInit = false;
	protected String syncChan;
	protected String inttype;

	public PromelaCodePrinter () {
		this (System.out, 8);
	}

	public PromelaCodePrinter (OutputStream os) {
		this (os, 8);
	}

	public PromelaCodePrinter (OutputStream os, int bitwidth) {
		super (new PrintWriter (os, true));
		// Can't use bytes, because they are unsigned in SPIN
		if (bitwidth <= 16)
			inttype = "short";
		else if (bitwidth <= 32)
			inttype = "int";
		else
			assert false : "bit width "+ bitwidth +" is too wide.";
	}

	protected void printPrelude () {
		// TODO: lazy, should use varGen in preprocessing pass
		syncChan = "__return";

		println ("/**");
		println (" *------------------------------------------------------");
		println (" * Automatically generated by the SKETCH compiler.");
		println (" *------------------------------------------------------");
		println (" */");
		println ("#define null (-1)");
		println ("mtype = { done };");
		println ("chan "+ syncChan +" = [2] of { mtype };");
		println ("hidden int "+ atomicCondLbl + ";");
		println ("");
	}

	public Object visitPackage (Package ss) {
        SymbolTable oldSymtab = symtab;
        symtab = new SymbolTable (symtab);

		printPrelude ();

		// Declare the globals
		for (FENode n : (List<FieldDecl>) ss.getVars ())
			n.accept (this);
		println ("");

		for (Function f : (List<Function>) ss.getFuncs ()) {
			if (f.getFcnType() == FcnType.Async)
				emitProcess (f);
			else if (null != f.getSpecification ()) {
				f.assertTrue (!sawInit, "sorry, only one 'main()' function allowed");
				sawInit = true;
				emitInit (f);
			}
		}

		symtab = oldSymtab;

		return null;
	}

	protected Object emitProcess (Function func) {
		SymbolTable oldSymtab = symtab;
        symtab = new SymbolTable (symtab);

		func.assertTrue (null == func.getSpecification (),
						 "internal error: sketches should be gone");

		List<Parameter> params = func.getParams ();

		printTab ();
		print ("proctype "+ func.getName ()+" (");

		for (int i = 0; i < params.size (); ++i) {
			Parameter param = params.get (i);

			print ((i != 0) ? "; " : "");
			param.accept (this);
			symtab.registerVar(param.getName(),
 (param.getType()),
	                           param,
	                           SymbolTable.KIND_FUNC_PARAM);
		}

		println (") {");
		func.getBody ().accept (this);
		indent ();
			println (syncChan +" ! done;  /* return */");
		dedent ();
		println ("}");
		println ("");

		symtab = oldSymtab;

		return func;
	}

	protected Object emitInit (Function func) {
		SymbolTable oldSymtab = symtab;
        symtab = new SymbolTable (symtab);

		println ("init");
		println ("{");

		indent ();
		// TODO: treat input params as nondeterministic local vars
		for (Parameter p : func.getParams ()) {
			printTab ();
			p.accept (this);
			println (";");
		}
		dedent ();

		func.getBody ().accept (this);
		println ("}");
		println ("");

		symtab = oldSymtab;

		return func;
	}

	public Object visitExprFunCall (ExprFunCall call) {
		List<Expression> params = call.getParams ();

		print ("run "+ call.getName ()+ "(");
		for (int i = 0; i < params.size (); ++i) {
			print ((i != 0) ? ", " : "");
			params.get (i).accept (this);
		}
		print (")");

		return call;
	}

	public Object visitExprTernary (ExprTernary et) {
		print ("((");
		et.getA ().accept (this);
		print (") -> ");
		et.getB ().accept (this);
		print (" : ");
		et.getC ().accept (this);
		print (")");

		return et;
	}

	public Object visitFieldDecl (FieldDecl fd) {
		quiet ();  super.visitFieldDecl (fd);  unquiet ();
		for (int i = 0; i < fd.getNumFields (); ++i) {
			printTab ();

			if (AddLastAssignmentToFork.PLACEHOLDER.equals (fd.getName (i)))
				print ("hidden ");

			printDecl (fd.getType (i), fd.getName (i), fd.getInit (i));
			println (";");
		}
		return fd;
	}

	public Object visitParameter (Parameter p) {
		quiet ();  super.visitParameter (p);  unquiet ();
		assert !p.isParameterReference ();
		printDecl (p.getType (), p.getName (), null);
		return p;
	}

	@Override
	public Object visitStmtAssert(StmtAssert stmt)
	{
		enterNumberedStmt (stmt);
		printTab ();
        print(stmt.getAssertSymbol() + " (");
		stmt.getCond ().accept (this);
		println (");  /* "+ stmt.getMsg () +" */");
		leaveNumberedStmt (stmt);
		return stmt;
	}

	@Override
	public Object visitStmtAssign(StmtAssign stmt)
	{
		enterNumberedStmt (stmt);
		super.visitStmtAssign (stmt);
		leaveNumberedStmt (stmt);
		return stmt;
	}

	public Object visitStmtAtomicBlock(StmtAtomicBlock block) {
		if (nAtomics == 0) {
			printlnIndent ("atomic {");
			indent ();
			printTab ();
		} else {
			assert !block.isCond ();
		}

		if (block.isCond ()) {
			// XXX: hack around weird way SPIN sometimes prints traces
			printAtomicCondLabel ((Integer) block.getTag ());
			block.getCond ().accept (this);
			print (" -> ");
		}
		if (nAtomics == 0) {
			assert null != block.getTag () && block.getTag () instanceof Integer
				: "unlabeled atomic block: '"+ block +"'";
			println ("_ = "+ block.getTag () +";");
		}
		enterAtomic ();
		for (Statement s : block.getBlock ().getStmts ())
			s.accept (this);
		leaveAtomic ();

		if (nAtomics == 0) {
			dedent ();
			printlnIndent ("}");
		}
		return block;
	}

	protected void printAtomicCondLabel (int lbl) {
		print ("("+ atomicCondLbl +"=="+ lbl + ")||");
	}

	public Object visitStmtBlock (StmtBlock stmt) {
		if (stmt.getStmts ().size () == 0) {
			printlnIndent ("{ skip; }");
			return stmt;
		} else
			return super.visitStmtBlock (stmt);
	}

	@Override
	public Object visitStmtBreak(StmtBreak stmt)
	{
		enterNumberedStmt (stmt);
		super.visitStmtBreak (stmt);
		leaveNumberedStmt (stmt);
		return stmt;
	}

	@Override
	public Object visitStmtContinue(StmtContinue stmt)
	{
		enterNumberedStmt (stmt);
		super.visitStmtContinue (stmt);
		leaveNumberedStmt (stmt);
		return stmt;
	}

	@Override
	public Object visitStmtDoWhile (StmtDoWhile stmt)
	{
		return assertEliminated (stmt);
	}

	@Override
	public Object visitStmtEmpty(StmtEmpty stmt)
	{
		printlnIndent("skip;");
		return stmt;
	}

	@Override
	public Object visitStmtExpr(StmtExpr stmt)
	{
		enterNumberedStmt (stmt);
		super.visitStmtExpr (stmt);
		leaveNumberedStmt (stmt);
		return null;
	}

	@Override
	public Object visitStmtFor (StmtFor stmt)
	{
		return assertEliminated (stmt);
	}

	@Override
	public Object visitStmtIfThen(StmtIfThen stmt)
	{
		assertThreadLocal (stmt.getCond ());

		printlnIndent ("if");
		printTab ();  print ("::");
		stmt.getCond ().accept (this);
		println (" -> ");
		stmt.getCons ().accept (this);
		printlnIndent (":: else");
		if (null != stmt.getAlt ()) {
			stmt.getAlt ().accept (this);
		} else {
			indent ();
			printStmtNumber (stmt);
			//printlnIndent ("skip;");
			dedent ();
		}
		printlnIndent ("fi;");
		return stmt;
	}

	@Override
	public Object visitStmtJoin(StmtJoin stmt)
	{
		printlnIndent (syncChan +" ? done;  /* join */");
		return null;
	}

	@Override
	public Object visitStmtLoop (StmtLoop stmt)
	{
		return assertEliminated (stmt);
	}

	public Object visitStmtReorderBlock(StmtReorderBlock block) {
		return assertEliminated (block);
	}

	@Override
	public Object visitStmtReturn(StmtReturn stmt)
	{
		return assertEliminated (stmt);
	}

	@Override
	public Object visitStmtVarDecl (StmtVarDecl svd)
	{
		quiet ();  super.visitStmtVarDecl (svd);  unquiet ();
		for (int i = 0; i < svd.getNumVars (); ++i) {
			printTab ();
			printDecl (svd.getType (i), svd.getName (i), /*svd.getInit (i)*/ null);
			println (";");
			if(svd.getInit(i)!= null){
				enterNumberedStmt(svd);
				printTab ();
				print(svd.getName(i));
				print (" = ");
				svd.getInit(i).accept (this);
				println (";");
				leaveNumberedStmt(svd);
			}
		}
		return svd;
	}

	@Override
	public Object visitStmtWhile(StmtWhile stmt)
	{
		assertThreadLocal (stmt.getCond ());

		printlnIndent ("do");
		printTab ();  print (":: !(");
		stmt.getCond ().accept (this);
		println (") -> break;");
		printlnIndent (":: else");
    	stmt.getBody().accept (this);
    	printlnIndent ("od;");
		return stmt;
	}

	public Object visitExprTypeCast (ExprTypeCast etc) {

		Type t = getType(etc.getExpr());
		if (t.equals (etc.getType ())) {
			print ("(");
			etc.getExpr ().accept (this);
			print (")");
		} else {
			etc.assertTrue (false, "CASTS NOT YET IMPLEMENTED");
		}
		return etc;
	}

	public Object visitTypePrimitive (TypePrimitive tp) {
        if (TypePrimitive.TYPE_BIT == tp.getType()) {
			print ("bool");
			return tp;
		} else if (TypePrimitive.TYPE_INT == tp.getType ()) {
			print (inttype);
			return tp;
		} else
			return super.visitTypePrimitive (tp);
	}

	public Object visitStructDef (StructDef ts) {
		quiet ();
		Object result = super.visitStructDef (ts);
		unquiet ();
		return result;
	}

	/* === HELPER METHODS === */

	/** Print this declaration in Promela style. */
	protected void printDecl (Type t, String name, Expression init) {
		if (t.isArray ()) {
			Type base = ((TypeArray) t).getBase ();
			assert !base.isArray ();
			base.accept (this);
		} else
			t.accept (this);
		print (" "+ name);
		if (t.isArray ())
			print ("["+ ((TypeArray)t).getLength () +"]");
		if (null != init) {
			print (" = ");
			init.accept (this);
		}
	}

	/** Print the label of STMT, if it's not inside an atomic block. */
	protected void printStmtNumber (Statement stmt) {
		if (nAtomics == 0) {
			Integer num = (Integer) stmt.getTag ();

			stmt.assertTrue (null != num, "Unnumbered statement: "+ stmt);
			stmt.assertTrue (num >= 0, "Invalid statement number");

			printlnIndent ("_ = "+ num +";");
		}
	}

	protected void enterNumberedStmt (Statement stmt) {
		if (nAtomics == 0) {
			printlnIndent ("atomic {");
			indent ();
			printStmtNumber (stmt);
		}
		enterAtomic ();
	}

	protected void leaveNumberedStmt (Statement stmt) {
		leaveAtomic ();
		if (nAtomics == 0) {
			dedent ();
			printlnIndent ("}");
		}
	}

	protected int nAtomics;
	protected void enterAtomic ()  { nAtomics++; }
	protected void leaveAtomic ()  { --nAtomics; assert nAtomics >= 0; }

	/** Ensure that N was eliminated in an earlier pass. */
	protected FENode assertEliminated (FENode n) {
		assert false : "Uh-oh: the node ("+ n +")\n"+
		  "was supposed to have been eliminated before this pass.";
		return n;
	}

	/**
	 * Assert that this statement is thread local; this is defined to be:
	 *
	 *   local(c) :- constant (c).
	 *   local(x) :- declIsLocal (x).
	 *   local(OP(x, y)) :- local (x), local (y).
	 */
	protected void assertThreadLocal (Expression e) {
		assert !isGlobal (e) :
			"Uh-oh: a non-local expression was used where a local one was expected";
	}
}
