/*
 * Copyright 2003 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 */

/*
 * StreamItParserFE.g: Sketch parser producing front-end tree
 * $Id: StreamItParserFE.g,v 1.41 2008/03/22 02:17:05 cgjones Exp $
 */

header {
package sketch.compiler.parser;

import java.io.DataInputStream;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Vector;
import java.util.Map;
import java.util.HashMap;

import sketch.compiler.Directive;
import sketch.compiler.ast.core.FEContext;
import sketch.compiler.ast.core.FieldDecl;
import sketch.compiler.ast.core.Function;
import sketch.compiler.ast.core.Parameter;
import sketch.compiler.ast.core.Program;
import sketch.compiler.ast.core.Annotation;
import sketch.compiler.ast.core.NameResolver;
import sketch.util.datastructures.HashmapList;
import sketch.compiler.ast.core.exprs.ExprStar.Kind;

import sketch.compiler.ast.core.Package;


import sketch.compiler.ast.core.exprs.*;
import sketch.compiler.ast.core.exprs.regens.*;
import sketch.compiler.ast.core.stmts.*;
import sketch.compiler.ast.core.typs.*;
import sketch.compiler.ast.cuda.exprs.*;
import sketch.compiler.ast.cuda.stmts.*;
import sketch.compiler.ast.cuda.typs.*;

import sketch.compiler.ast.promela.stmts.StmtFork;
import sketch.compiler.main.cmdline.SketchOptions;

import sketch.compiler.ast.spmd.stmts.StmtSpmdfork;

import static sketch.util.DebugOut.assertFalse;
}

{@SuppressWarnings("deprecation")}
class StreamItParserFE extends Parser;
options {
    // NOTE -- increase lookahead depth to support previously
    // ambiguous expressions like expr_named_param
    k = 2;
	importVocab=StreamItLex;	// use vocab generated by lexer
}

{
	private Set<String> processedIncludes=new HashSet<String> ();
    private Set<Directive> directives = new HashSet<Directive> ();
    private boolean preprocess;
    private List<String> cppDefs;
    private String currPkg;
    private FEContext curPkgCx;    
    private FEContext lastCx=null;
    private String lastFilename = null;
    private String shortFilename = null;
    
     //ADT
    private List<String> parentStructNames = new ArrayList<String>();

	public StreamItParserFE(StreamItLex lexer, Set<String> includes,
                            boolean preprocess, List<String> cppDefs)
	{
		this(lexer);
		processedIncludes = includes;
        this.preprocess = preprocess;
        this.cppDefs = cppDefs;
	}

	public static void main(String[] args)
	{
		try
		{
			DataInputStream dis = new DataInputStream(System.in);
			StreamItLex lexer = new StreamItLex(dis);
			StreamItParserFE parser = new StreamItParserFE(lexer);
			parser.program();
		}
		catch (Exception e)
		{
			e.printStackTrace(System.err);
		}
	}

	public FEContext getContext(Token t)
	{
		int line = t.getLine();
		if (line == 0) line = -1;
		int col = -1;
		String filename = getFilename();
		
		
		if(lastCx != null){
			if(line == lastCx.getLineNumber() && lastFilename != null && lastFilename.equals(filename)){
				return lastCx;
			}
		}
		
		if(lastFilename == null || !lastFilename.equals(filename)){
			lastFilename = filename;
			String lfile = filename;
			if(lfile.length() > 15){
	    		int ls=lfile.lastIndexOf("/");
	    		{
	        		int lb=lfile.lastIndexOf("\\");
	        		if(ls<0 || lb>ls) ls=lb;
	    		}
	    		if(ls>=0) lfile = lfile.substring(ls+1);
	            if (lfile.length() > 17) {
	                lfile =
	                        lfile.substring(0, 7) + ".." +
	                                lfile.substring(lfile.length() - 9);
	        	}
	    	}
	    	shortFilename = lfile;	
		}		
		lastCx = new FEContext(shortFilename, line, col, StreamItLex.lastComment);	
		return lastCx;
		
		// int col = t.getColumn();
		// if (col == 0) col = -1;		
	}

	private boolean hasError = false;

	public void reportError(RecognitionException ex)
	{
		hasError = true;
		super.reportError(ex);
	}

	public void reportError(String s)
	{
		hasError = true;
		super.reportError(s);
	}

    public void handleInclude(String name, List<Package> namespace)
    {
        try {
            List<String> incList = Arrays.asList(
                    SketchOptions.getSingleton().feOpts.inc);
        	Iterator<String> lit = null;
        	if(incList != null){ lit = incList.iterator(); }
        	File f = new File (name);
        	String errMsg = "";
        	while(!f.canRead()){
        		if(lit != null && lit.hasNext()){
        			errMsg += "\n\t" +  f.getCanonicalPath();
        			String tmp = lit.next(); 
        			File tmpf = new File(tmp);
        			String dir = tmpf.getCanonicalPath();
        			f = new File (dir, name);	
        		}else{
        			errMsg += "\n\t" + f.getCanonicalPath();
        			throw new IllegalArgumentException ("File not found: "+ name + "\n" + 
        					"Searched the following paths:" + errMsg + "\n");
        		}
        	}
            name = f.getCanonicalPath ();
        } catch (IOException ioe) {
            throw new IllegalArgumentException ("File not found: "+ name);
        }
        if (processedIncludes.contains(name))
            return;
        processedIncludes.add(name);
        StreamItParser parser =
            new StreamItParser (name, processedIncludes, preprocess, cppDefs);
        Program p = parser.parse ();
		assert p != null;		
		
		namespace.addAll(p.getPackages());		
        directives.addAll (parser.getDirectives ());
    }

    private void handlePragma (String pragma, String args) {
        directives.add (Directive.make (pragma, args));
    }

    public Set<Directive> getDirectives () {  return directives;  }

}// end of ANTLR header block

program	 returns [Program p]
{   Package pk;
    p = null; List vars = new ArrayList();  
	List<Function> funcs=new ArrayList(); Function f;
	List<Package> namespaces = new ArrayList<Package>();
    FieldDecl fd; StructDef ts; List<StructDef> structs = new ArrayList<StructDef>();
    List<StructDef> adtList;
   
    String file = null;
    String pkgName = null;
    FEContext pkgCtxt = null;
    List<StmtSpAssert> specialAsserts = new ArrayList<StmtSpAssert>();
	StmtSpAssert sa;
}
	:	(  (annotation_list (/*TK_device  | TK_global |*/  TK_serial | TK_harness |
                     TK_generator |  TK_stencil | TK_model)*
                    return_type ID  (type_params)? LPAREN) => f=function_decl { funcs.add(f); }
           |    (return_type ID (type_params)? LPAREN) => f=function_decl { funcs.add(f); } 
		   | 	fd=field_decl SEMI { vars.add(fd); }
           |    (annotation_list TK_struct) => ts=struct_decl { structs.add(ts); }
           |    adtList=adt_decl { structs.addAll(adtList); }
           |    sa = special_assert_statement { specialAsserts.add(sa); }
           |    file=include_stmt { handleInclude (file, namespaces); }
           |    TK_package id:ID { currPkg = (id.getText()); curPkgCx = getContext(id);}
                            (SEMI {pkgName = currPkg;  pkgCtxt = getContext(id); StreamItLex.lastComment = null;} | pk = pkgbody {namespaces.add(pk);  } ) 
           |    pragma_stmt
        )*
		EOF
		{
			if(pkgName == null){
				pkgName="ANONYMOUS";
			}
			for(StructDef struct : structs){
				if(parentStructNames.contains(struct.getName())) struct.setIsInstantiable(false);
				struct.setPkg(pkgName);	
			}
			for(Function fun : funcs){
				fun.setPkg(pkgName);	
			}
			
		        Package ss=new Package(pkgCtxt, pkgName, structs, vars, funcs, specialAsserts);
 				namespaces.add(ss);
                if (!hasError) {
                    if (p == null) {
                        p = Program.emptyProgram();
                    }
                    p =
                    p.creator().streams(namespaces).create();
                }
        }
	;


pkgbody returns [Package pk] 
{
    pk = null;
    FieldDecl fd; 
	List vars = new ArrayList();  
	List<Function> funcs=new ArrayList(); Function f;
	parentStructNames = new ArrayList<String>();
	StructDef ts; List<StructDef> structs = new ArrayList<StructDef>();
	List<StructDef> adtList;
	FEContext pkgCtxt = null;
	List<StmtSpAssert> specialAsserts = new ArrayList<StmtSpAssert>();
	StmtSpAssert sa;
}
: 
	LCURLY
  (  (annotation_list (/*TK_device  | TK_global |*/  TK_serial | TK_harness |
                     TK_generator |  TK_stencil | TK_model)*
                    return_type ID (type_params)? LPAREN) => f=function_decl { funcs.add(f); }
           |    (return_type ID (type_params)? LPAREN) => f=function_decl { funcs.add(f); } 
		   | 	fd=field_decl SEMI { vars.add(fd); }
           |    (annotation_list TK_struct) => ts=struct_decl { structs.add(ts); }
           |    adtList=adt_decl { structs.addAll(adtList); }
           |    sa = special_assert_statement { specialAsserts.add(sa); }
   )*
   RCURLY
   {			
		for(StructDef struct : structs){
			if(parentStructNames.contains(struct.getName())) struct.setIsInstantiable(false);
			struct.setPkg(currPkg);	
		}
		for(Function fun : funcs){
			fun.setPkg(currPkg);	
		}
		
	    pk=new Package(pkgCtxt, currPkg, structs, vars, funcs, specialAsserts);
    }
   ;

include_stmt    returns [String f]  { f = null; }
    :   TK_include fn:STRING_LITERAL SEMI
        {   f = fn.getText ();  f = f.substring (1, f.length () - 1);  }
    ;

pragma_stmt { String args = ""; }
    : TK_pragma p:ID
        ( a:STRING_LITERAL   { args = a.getText ().substring (1, a.getText ().length ()-1); } )?
        SEMI
        { handlePragma (p.getText (), args); }
    ;


field_decl returns [FieldDecl f] { f = null; Type t; Expression x = null;
	List ts = new ArrayList(); List ns = new ArrayList();
	List xs = new ArrayList(); FEContext ctx = null; }
	:	t=data_type id:ID (ASSIGN x=expr_or_lambda)?
		{ ctx = getContext(id); ts.add(t); ns.add(id.getText()); xs.add(x); }
		(
			{ x = null; }
			COMMA id2:ID (ASSIGN x=expr_or_lambda)?
			{ ts.add(t); ns.add(id2.getText()); xs.add(x); }
		)*
		{ f = new FieldDecl(ctx, ts, ns, xs); StreamItLex.lastComment = null;  }
	;





statement returns [Statement s] { s = null; }
	:	s=loop_statement //1
	|   s=minrepeat_statement
	|   s=fork_statement
    |   s=spmdfork_statement
    |   s=parfor_statement // 5
	|	s=insert_block
	|	s=reorder_block
	|	s=atomic_block
	|	(LCURLY)=> s=block // 9
	|(return_type ID LPAREN) =>s=fdecl_statement
	|	(data_type ID) => s=variable_decl SEMI!
    // |   (ID DEF_ASSIGN) => s=implicit_type_variable_decl SEMI!
	|	(expr_statement) => s=expr_statement SEMI!
	|	tb:TK_break SEMI { s = new StmtBreak(getContext(tb)); }
	|	tc:TK_continue SEMI { s = new StmtContinue(getContext(tc)); }
	//ADT
	|	s=switch_statement
	|	s=if_else_statement
	|	s=while_statement
	|	s=do_while_statement SEMI
	|	s=for_statement
	|	s=assume_statement SEMI
	|	s=assert_statement SEMI
	|	s=assert_max_statement SEMI
	|   s=hassert_statement SEMI
	|(annotation_list (TK_device | TK_serial | TK_harness |
                     TK_generator | TK_library | TK_printfcn | TK_stencil | TK_model)*
                    return_type ID LPAREN) =>s=fdecl_statement  
	|s=return_statement SEMI
	|t:SEMI {s=new StmtEmpty(getContext(t));}
	;

fdecl_statement returns [Statement s] { s=null; Function f = null;}
	: f = function_decl { s = new StmtFunDecl(f.getCx(), f); }
	;
	
loop_statement returns [Statement s] { s = null; Expression exp; Statement b; Token x=null;}
	:
	
	((TK_loop{x=t1;} | TK_repeat{x=t2;}) LPAREN ID COLON) => 
	(t1:TK_loop{x=t1;} | t2:TK_repeat{x=t2;}) LPAREN id:ID COLON exp=right_expr RPAREN b=pseudo_block
	{
	 FEContext cx = getContext(x); 
	 s = 
						new StmtBlock(
						new StmtVarDecl(cx, TypePrimitive.inttype, id.getText(), ExprConstInt.zero),
						new StmtLoop(cx, exp, 
						  new StmtBlock(b, new StmtExpr(						          
						          new ExprUnary(cx, ExprUnary.UNOP_PREINC, new ExprVar(cx,id.getText())) ))						
						)
						); 
	
	}
	
	
	| (t1p:TK_loop{x=t1p;} | t2p:TK_repeat{x=t2p;}) LPAREN exp=right_expr RPAREN b=pseudo_block
	{ s = new StmtLoop(getContext(x), exp, b); }
	;

minrepeat_statement returns [Statement s] { s = null; Statement b; Token x=null;}
    : (t1:TK_minrepeat{x=t1;}) b=pseudo_block
    { s = new StmtMinLoop(getContext(x), b); }
    ;

fork_statement returns [Statement s] { s = null; Statement ivar; Expression exp; Statement b;}
	: t:TK_fork LPAREN ivar=variable_decl SEMI exp=right_expr RPAREN b=pseudo_block
	{ s = new StmtFork(getContext(t), (StmtVarDecl) ivar, exp, b); }
	;

spmdfork_statement returns [Statement s] { s = null; String ivar=null; Expression exp; Statement b;}
	: t:TK_spmdfork LPAREN (v:ID {ivar=v.getText();} SEMI)? exp=right_expr RPAREN b=pseudo_block
	{ s = new StmtSpmdfork(getContext(t), ivar, exp, b); }
	;

parfor_statement returns [Statement s] { s = null; Expression ivar; Expression exp; Statement b; }
    : t:TK_parfor LPAREN ivar=var_expr LARROW exp=range_exp RPAREN b=pseudo_block
    { s = new StmtParfor(getContext(t), ivar, exp, b); }
    ;

range_exp returns [Expression e] { e = null; Expression from; Expression until; Expression by = new ExprConstInt(1); }
    : from=right_expr t:TK_until until=right_expr (TK_by by=right_expr)? { }
    { e = new ExprRange(getContext(t), from, until, by); }
    ;


type_params_use returns [List<Type> t]{ t = new ArrayList<Type>();  Type p; Type temp;}
:
(LESS_THAN 
(ID AT)? ID
LESS_THAN
p=data_type
RSHIFT
) => 
LESS_THAN 
(prefix:ID AT)? id:ID 
LESS_THAN
p=data_type
RSHIFT { 
List<Type> plist = new ArrayList<Type>();
plist.add(p); 
t.add(new TypeStructRef(prefix != null ? (prefix.getText() + "@" + id.getText() )  : id.getText(), false, plist)); }
|
LESS_THAN p=data_type {t.add(p);} 
          (COMMA p=data_type {t.add(p);} )*  
MORE_THAN
;

data_type returns [Type t] { t = null; List<Type> tp; Vector<Expression> params = new Vector<Expression>(); Vector<Integer> maxlens = new Vector<Integer>(); int maxlen = 0; Expression x; boolean isglobal = false; }
	:	 (TK_global {isglobal = true; })? 
                (t=primitive_type 
                | (prefix:ID AT)? id:ID { t = new TypeStructRef(prefix != null ? (prefix.getText() + "@" + id.getText() )  : id.getText(), false); }
                | BITWISE_OR (prefix2:ID AT)? id2:ID BITWISE_OR { t = new TypeStructRef(prefix2 != null ? (prefix2.getText() + "@" + id2.getText() )  : id2.getText(), true); })
		
		( tp = type_params_use { if(!(t instanceof TypeStructRef)){ throw new RuntimeException("ERROR!!!"); } ((TypeStructRef)t).addParams(tp); } )?
		(	l:LSQUARE
			(	
                ( { maxlen = 0; }
                (x=expr_named_param
                	(
					LESS_COLON n:NUMBER { maxlen = Integer.parseInt(n.getText()); }
					)?
				{ params.add(x); maxlens.add(maxlen); }
				)
				| {params.add(null); maxlens.add(maxlen); })

                ( { maxlen = 0; }
                COMMA x=expr_named_param  
                    (
                    LESS_COLON num:NUMBER { maxlen = Integer.parseInt(num.getText()); }
					)?
				{ params.add(x); maxlens.add(maxlen); }
				)*
			)
            RSQUARE
            {
                while (!params.isEmpty()) {
                    t = new TypeArray(t, params.lastElement(), maxlens.lastElement());
                    params.remove(params.size() - 1);
                    maxlens.remove(maxlens.size() - 1);
                }
            }
		)*
		{
                    if (isglobal) { t = t.withMemType(CudaMemoryType.GLOBAL); } 
                }
	|	TK_void { t =  TypePrimitive.voidtype; }
	;

primitive_type returns [Type t] { t = null; }
	:
		(TK_boolean { t = TypePrimitive.bittype; }
	|	TK_bit { t = TypePrimitive.bittype;  }
	|	TK_int { t = TypePrimitive.inttype;  }
	|	TK_float { t = TypePrimitive.floattype;  }
	|	TK_double { t = TypePrimitive.doubletype; }
	|   TK_fun { t = TypeFunction.singleton; }
	|	TK_char { t = TypePrimitive.chartype; })
	;

variable_decl returns [Statement s] { s = null; Type t; Expression x = null;
	List ts = new ArrayList(); List ns = new ArrayList();
	List xs = new ArrayList(); }
	:	t=data_type
		id:ID
		(ASSIGN x=expr_or_lambda)?
		{ ts.add(t); ns.add(id.getText()); xs.add(x); }
		(
			{ x = null; }
			COMMA id2:ID (ASSIGN x=expr_or_lambda)?
			{ ts.add(t); ns.add(id2.getText()); xs.add(x); }
		)*
		{ s = new StmtVarDecl(getContext (id), ts, ns, xs); }
	;


expr_or_lambda returns [Expression e] { e = null; }
:
   (LPAREN (RPAREN | ID (RPAREN ARROW | COMMA)   )  ) => e = lambda_expr
   | e=right_expr
;

annotation returns [Annotation an]{
	an = null;
}: atc:AT id:ID LPAREN (slit:STRING_LITERAL)? RPAREN
{
	an = Annotation.newAnnotation(getContext(atc), id.getText(), slit == null? "" : slit.getText());
}
;

annotation_list returns [HashmapList<String, Annotation>  amap] {
	 amap=null; Annotation an; }
	:	
		( an=annotation {if(amap==null){amap = new HashmapList<String, Annotation>();} amap.append(an.tag, an); })*
	;

type_params returns [List<String> ls] { ls = new ArrayList<String>(); } 
:
LESS_THAN id1:ID { ls.add(id1.getText()); } (COMMA id:ID { ls.add(id.getText()); } )* MORE_THAN ;

function_decl returns [Function f] {
    Type rt;
    List l;
    StmtBlock s;
    HashmapList<String, Annotation> amap;
    f = null;
    boolean isHarness = false;
    boolean isLibrary = false;
    boolean isPrintfcn = false;
    boolean isGenerator = false;
    boolean isDevice = false;
    boolean isGlobal = false;
    boolean isSerial = false;
    boolean isStencil = false;
    boolean isModel = false;
    List<String> tp=null;
    List<String> fixes = new ArrayList<String>();
    FEContext funCx = null;
}
	:
	amap=annotation_list
	( 
          TK_serial { isSerial = true; } |
          TK_harness { isHarness = true; } |
          TK_generator { isGenerator = true; }  |      
          TK_stencil { isStencil = true; } | 
          TK_model { isModel = true; }
          
        )*
	rt=return_type
	id:ID
	(tp=type_params)?
	l=param_decl_list { funCx = getContext(id); StreamItLex.lastComment = null;}
	(TK_implements impl:ID)?
	(TK_fixes  ( name:ID{ fixes.add(name.getText());  } ) )?
	( s=block
	{
            assert !(isGenerator && isHarness) : "The generator and harness keywords cannot be used together";
            Function.FunctionCreator fc = Function.creator(funCx, id.getText(), Function.FcnType.Static).returnType(
                rt).params(l).body(s).annotations(amap).typeParams(tp).fixes(fixes);

            // function type
            if (isGenerator) {
                fc = fc.type(Function.FcnType.Generator);
            } else if (isHarness) {
                assert impl == null : "harness functions cannot have implements";
                fc = fc.type(Function.FcnType.Harness);
            } else if (isModel) {
                assert impl == null : "A model can not implement another model or a concrete function";
                fc = fc.type(Function.FcnType.Model);
            } else if (impl != null) {
                fc = fc.spec(impl.getText());
            }

            // library type
            if (isLibrary) {
                fc = fc.libraryType(Function.LibraryFcnType.Library);
            }

            // print function
            if (isPrintfcn) {
                fc = fc.printType(Function.PrintFcnType.Printfcn);
            }

            // cuda type annotations
            if ((isDevice && isGlobal) || (isGlobal && isSerial) || (isDevice && isSerial)) {
                assertFalse("Only one of \"global\", \"device\", or \"serial\" qualifiers is allowed.");
            }
            if (isDevice) {
                fc = fc.cudaType(Function.CudaFcnType.DeviceInline);
            } else if (isGlobal) {
                fc = fc.cudaType(Function.CudaFcnType.Global);
            } else if (isSerial) {
                fc = fc.cudaType(Function.CudaFcnType.Serial);
            }

            // stencil type
            if (isStencil) {
                fc = fc.solveType(Function.FcnSolveType.Stencil);
            }

            f = fc.create();
	}
	| SEMI  { f = Function.creator(funCx, id.getText(), isGenerator? Function.FcnType.UninterpGenerator : Function.FcnType.Uninterp).returnType(rt).params(l).annotations(amap).create(); })
	;

return_type returns [Type t] { t=null; }
	: 	t=data_type
	;

param_decl_list returns [List l] { l = new ArrayList(); List l2; Parameter p; }
	:	LPAREN
		(l2=impl_param {l.addAll(l2); })?
		(p=param_decl { l.add(p); } (COMMA p=param_decl { l.add(p); })*
		)?
		RPAREN
	;

impl_param returns [List l]{ Parameter p; l = new ArrayList(); }
	: LSQUARE TK_int id:ID {p= new Parameter(getContext(id), TypePrimitive.inttype, id.getText(), Parameter.IN, true); l.add(p);}
	  (COMMA TK_int id2:ID {p= new Parameter(getContext(id), TypePrimitive.inttype, id2.getText(), Parameter.IN, true); l.add(p);})* 
	  RSQUARE COMMA
	;
param_decl returns [Parameter p] { Type t; p = null; boolean isRef=false; }
	: 	(TK_ref { isRef=true;} )?	 t=data_type id:ID { p = new Parameter(getContext(id), t, id.getText(), isRef? Parameter.REF : Parameter.IN, false); }
	;

block returns [StmtBlock sb] { sb=null; Statement s; List l = new ArrayList(); }
	:	t:LCURLY ( s=statement { l.add(s); } )* RCURLY
		{ sb = new StmtBlock(getContext(t), l); }
	;

insert_block returns [StmtInsertBlock ib]
    { ib=null; Statement s; List<Statement> insert = new ArrayList<Statement> (), into = new ArrayList<Statement> (); }
	:	t:TK_insert LCURLY ( s=statement { insert.add(s); } )* RCURLY
		TK_into   LCURLY ( s=statement { into.add(s); } )* RCURLY
		{ ib = new StmtInsertBlock(getContext(t), insert, into); }
	;


reorder_block returns [StmtReorderBlock sb] { sb=null; Statement s; List l = new ArrayList(); }
	:	TK_reorder t:LCURLY ( s=statement { l.add(s); } )* RCURLY
		{ sb = new StmtReorderBlock(getContext(t), l); }
	;

atomic_block returns [StmtAtomicBlock ab] { ab=null; Expression c = null; StmtBlock b = null; }
	:   t:TK_atomic (LPAREN c=right_expr RPAREN)? b=block
		{ ab = new StmtAtomicBlock (getContext (t), b.getStmts (), c); }
	;

pseudo_block returns [StmtBlock sb] { sb=null; Statement s; List l = new ArrayList(); }
	:	 s=statement { l.add(s); }
		{ sb = new StmtBlock(s.getContext(), l); }
	;

return_statement returns [StmtReturn s] { s = null; Expression x = null; }
	:	t:TK_return (x=right_expr)? { s = new StmtReturn(getContext(t), x); }
	;

assume_statement returns [StmtAssume s] { s = null; Expression cond; }
	:   (t:TK_assume) cond = right_expr (COLON ass:STRING_LITERAL)? {
			if (cond != null) {
				String msg = null;
				FEContext cx =getContext(t);
				if(ass!=null){
					String ps = ass.getText();
			        ps = ps.substring(1, ps.length()-1);
					msg = cx + "   "+ ps;	
				}
				s = new StmtAssume(cx, cond, msg);
			}
		}
	;

special_assert_statement returns [StmtSpAssert s] { s = null; List<String> bindingsInOrder = new ArrayList<String>(); Map<String, Expression> set = new HashMap<String, Expression>(); Expression preCond = null; List<Expression> asserts = new ArrayList<Expression>(); Expression x; }
	: ((t : TK_let) ((name:ID ASSIGN x = right_expr) {
			set.put(name.getText(), x);
			bindingsInOrder.add(name.getText());
		} (COMMA name1:ID ASSIGN x = right_expr {
				set.put(name1.getText(), x); 
				bindingsInOrder.add(name1.getText()); })* )?
	  ) LCURLY
	  ((t1: TK_assume) preCond = right_expr)?
	  ((t2 : TK_assert) x = right_expr SEMI {
			asserts.add(x);
		})
	  ((t3 : TK_assert) x = right_expr SEMI {
			asserts.add(x);
		})* {
		s = new StmtSpAssert(getContext(t), set, preCond, asserts, bindingsInOrder);
		}
		RCURLY
	| ((t4 : TK_assert) x = right_expr SEMI {
			asserts.add(x);
			s = new StmtSpAssert(getContext(t4), set, preCond, asserts, bindingsInOrder);
		})
	;
	
assert_statement returns [StmtAssert s] { s = null; Expression x; }
	:	(t1:TK_assert | t2:TK_h_assert) x=right_expr (COLON ass:STRING_LITERAL)?{
		String msg = null;
		Token t = t1;
		if(t==null){ t=t2;}
		FEContext cx =getContext(t); 
		if(ass!=null){
			String ps = ass.getText();
	        ps = ps.substring(1, ps.length()-1);
			msg = cx + "   "+ ps;	
		}
		s = new StmtAssert(cx, x, msg, t2!=null); }	
	;

hassert_statement returns [StmtAssert s] { s = null; Expression x; }
	:	(t1:TK_hassert) x=right_expr (COLON ass:STRING_LITERAL)?{
		String msg = null;
		Token t = t1;
		FEContext cx =getContext(t); 
		if(ass!=null){
			String ps = ass.getText();
	        ps = ps.substring(1, ps.length()-1);
			msg = cx + "   "+ ps;	
		}
		s = new StmtAssert(cx, x, msg, false, true); }	
	;
	
assert_max_statement returns [StmtAssert s] { s = null; Expression cond; ExprVar var; }
:	t:TK_assert_max (defer: BACKSLASH)? cond=right_expr (COLON ass:STRING_LITERAL)? { 
	FEContext cx = getContext(t);
	String msg = null;
	if (ass != null) {
		String ps = ass.getText();
		ps = ps.substring(1, ps.length()-1);
		msg = cx + "   "+ ps;
	}
	s = StmtAssert.createAssertMax(cx, cond, msg, (defer!=null)); }	
;
//ADT
switch_statement returns [Statement s]
{ s = null; ExprVar  x;  Statement b =null; }
	:	u:TK_switch LPAREN name:ID RPAREN LCURLY
	 
		{x = new ExprVar(getContext(name), name.getText()); s= new StmtSwitch(getContext(u), x); }
		(TK_case caseName:ID COLON b= pseudo_block
		{((StmtSwitch)s).addCaseBlock(caseName.getText(), b);}
		)*
		((TK_default COLON b = pseudo_block
		{((StmtSwitch)s).addCaseBlock("default",b);}
		)
		|
		(TK_repeat_case COLON b = pseudo_block
		{((StmtSwitch)s).addCaseBlock("repeat", b);}))?
		RCURLY
		
	;
	 

	
if_else_statement returns [Statement s]
{ s = null; Expression x; Statement t, f = null; }
	:	u:TK_if LPAREN x=right_expr RPAREN t=pseudo_block
		((TK_else) => (TK_else f=pseudo_block))?
		{ s = new StmtIfThen(getContext(u), x, t, f); }
	;

while_statement returns [Statement s] { s = null; Expression x; Statement b; }
	:	t:TK_while LPAREN x=right_expr RPAREN b=pseudo_block
		{ s = new StmtWhile(getContext(t), x, b); }
	;

do_while_statement returns [Statement s]
{ s = null; Expression x; Statement b; }
	:	t:TK_do b=pseudo_block TK_while LPAREN x=right_expr RPAREN
		{ s = new StmtDoWhile(getContext(t), b, x); }
	;

for_statement returns [Statement s]
{ s = null; Expression x=null; Statement a, b, c; }
	:	t:TK_for LPAREN a=for_init_statement SEMI
		(x=right_expr | { x = ExprConstInt.one; })
		SEMI b=for_incr_statement RPAREN c=pseudo_block
		{ s = new StmtFor(getContext(t), a, x, b, c, false); }
	;

for_init_statement returns [Statement s] { s = null; }
	:	(variable_decl) => s=variable_decl
    // |   (implicit_type_variable_decl) => s=implicit_type_variable_decl
	|	(expr_statement) => s=expr_statement
	|   /* empty */ { s = new StmtEmpty((FEContext)null); }
	;

for_incr_statement returns [Statement s] { s = null; }
	:	s=expr_statement
	|   /* empty */ { s = new StmtEmpty((FEContext) null); }
	;

expr_statement returns [Statement s] { s = null; Expression x; }
	:	 s=assign_expr
	//|	(ID (AT ID)? LPAREN) => x=func_call { s = new StmtExpr(x); }
	;

assign_expr returns [Statement s] { s = null; Expression l, r; int o = 0; String fname = null;}
	:	l=prefix_expr
		( (
			(	ASSIGN { o = 0; }
			|	PLUS_EQUALS { o = ExprBinary.BINOP_ADD; }
			|	MINUS_EQUALS { o = ExprBinary.BINOP_SUB; }
			|	STAR_EQUALS { o = ExprBinary.BINOP_MUL; }
			|	DIV_EQUALS { o = ExprBinary.BINOP_DIV; }
			|   DOTASSIGN { fname = "op.="; }
			)
			r=expr_or_lambda
			{ if(fname == null){ 
				s = new StmtAssign(l, r, o); s.resetOrigin();
			  }else{
			  	s = new StmtExpr(new ExprFunCall(l.getCx(), fname, l, r));
			  }	
			}
		  )
			| 
		{ s = new StmtExpr(l);  }	
		)
	;

func_call returns [Expression x] { x = null; List l; }
	: prefix:ID (AT name:ID)? l=func_call_params
		{ x = new ExprFunCall(getContext(prefix), prefix.getText()+ (name != null ? ("@" + name.getText()) : ""), l); }
	
	;

expr_get returns [Expression x] { x = null; List l; }
	: t:NDVAL2 LPAREN LCURLY l = expr_get_params RCURLY RPAREN
		{ x = new ExprADTHole(getContext(t), l); }
	;
	
expr_get_params returns [List l] { l = new ArrayList(); Expression x; }
	:	
		(	x=expr_named_param { l.add(x); }
			(COMMA x=expr_named_param { l.add(x); })*
		)?
		
	;
	
func_call_params returns [List l] { l = new ArrayList(); Expression x; }
	:	LPAREN
		(	x=expr_named_param { l.add(x); }
			(COMMA x=expr_named_param { l.add(x); })*
		)?
		RPAREN
	;

// (,x, y) -> x + y; 	
lambda_expr returns [Expression expression]  {
	expression = null;
	List list = new ArrayList();
	Expression operation = null;
}
	: // Left parenthesis 
	  prefix:LPAREN 
  	  
  	  // A group that occurs 0 or 1 times
  	  (
	  	  temp1:ID { 
		  		// Create a new ExprVar and add it to the list of variables
		  		list.add(new ExprVar(getContext(temp1), temp1.getText())); 
		  	}
	  	  // Group that occurs 0 or more times
	  	  (
	  	    COMMA
		  	// Match an ID and set temp to it
		  	temp2:ID { 
		  		// Create a new ExprVar and add it to the list of variables
		  		list.add(new ExprVar(getContext(temp2), temp2.getText())); 
		  	}
	  	  )*
  	  )?
		 
	  // Right parenthesis
	  RPAREN
	  // ->
	  ARROW
	  // Operation is any expression
	  operation = right_expr
	  {
	  	// Create a new expression
	  	expression = new ExprLambda(getContext(prefix), list, operation);
	  }
	;
	
constr_params returns [List l] { l = new ArrayList(); Expression x; }
	:	LPAREN
		(	x=expr_named_param_only { l.add(x); }
			(COMMA x=expr_named_param { l.add(x); })*
		)?
		RPAREN
	;

expr_named_param returns [ Expression x ] { x = null; Token t = null; }
    :   (id:ID ASSIGN)? { t = id; }
        x= expr_or_lambda
        {
            if (t != null) {
                x = new ExprNamedParam(getContext(t), t.getText(), x);
            }
        }
    ;

expr_named_param_only returns [ Expression x ] { x = null; Token t = null; }
    :   id:ID ASSIGN x=right_expr { x = new ExprNamedParam(getContext(id), id.getText(), x); }
    ;


        
right_expr_not_agmax returns [Expression x] { x = null; }
	:	x=ternaryExpr	
	;
right_expr returns [Expression x] { x = null; }
	:	x=right_expr_not_agmax
	;

/*agmax_expr returns [Expression x] { x = null; }
 	:	t:NDANGELIC (LPAREN n:NUMBER RPAREN)?
    	{
    		if (n != null) {
    			x = new ExprStar(getContext(t), Integer.parseInt(n.getText()), Kind.ANGELIC);
    		} else {
    			x = new ExprStar(getContext(t), Kind.ANGELIC);
    		}
    	} 
	;*/
	
/*
TODO we don't add exprMax now
agmax_expr returns [Expression x] { x = null; Expression exprMax = null; }
 	:	t:NDANGELIC (LPAREN n:NUMBER RPAREN)? (AT exprMax=right_expr_not_agmax)?
    	{
    		if (n != null) {
    			x = new ExprStar(getContext(t), Integer.parseInt(n.getText()), true, exprMax);
    		} else {
    			x = new ExprStar(getContext(t), true, exprMax);
    		}
    	} 
	;
*/




arr_initializer returns [Expression x] { ArrayList l = new ArrayList();
                                         x = null;
                                         Expression y; }
    : lc:LCURLY
      ( y=right_expr { l.add(y); }
            (COMMA y=right_expr { l.add(y); })*
      )?
      RCURLY
        { x = new ExprArrayInit(getContext(lc), l); }
    ;

ternaryExpr returns [Expression x] { x = null; Expression b, c; }
	:	x=logicOrExpr
		(QUESTION b=ternaryExpr COLON c=ternaryExpr
			{ x = new ExprTernary(x, ExprTernary.TEROP_COND,
					x, b, c); }
		)?
	;

logicOrExpr returns [Expression x] { x = null; Expression r; int o = 0; }
	:	x=logicAndExpr
		(LOGIC_OR r=logicAndExpr
			{ x = new ExprBinary(ExprBinary.BINOP_OR, x, r); }
		)*
	;

logicAndExpr returns [Expression x] { x = null; Expression r; }
	:	x=bitwiseOrExpr
		(LOGIC_AND r=bitwiseOrExpr
			{ x = new ExprBinary(ExprBinary.BINOP_AND, x, r); }
		)*
	;

bitwiseOrExpr returns [Expression x] { x = null; Expression r; }
	:	x=bitwiseXorExpr
		(	BITWISE_OR  r=bitwiseXorExpr
			{ x = new ExprBinary(ExprBinary.BINOP_BOR, x, r); }
		)*
	;

bitwiseXorExpr returns [Expression x] { x = null; Expression r; }
    :   x=bitwiseAndExpr
        (   BITWISE_XOR  r=bitwiseAndExpr
            { x = new ExprBinary(ExprBinary.BINOP_BXOR, x, r); }
        )*
    ;

bitwiseAndExpr returns [Expression x] { x = null; Expression r; }
    :   x=equalExpr
        (   BITWISE_AND  r=equalExpr
            { x = new ExprBinary(ExprBinary.BINOP_BAND, x, r); }
        )*
    ;

equalExpr returns [Expression x] { x = null; Expression r; Expression last; int o = 0; }
	:	x=compareExpr {last=x;}
		(	( EQUAL     { o = ExprBinary.BINOP_EQ; }
			| TRIPLE_EQUAL { o = ExprBinary.BINOP_TEQ; }
			| NOT_EQUAL { o = ExprBinary.BINOP_NEQ; }
			)
			r = compareExpr
			{ x = new ExprBinary(o, x, r); }
		)*
	;

compareExpr returns [Expression x] { x = null; Expression r; int o = 0; String fname=null;}
	:	x=shiftExpr
		(	( LESS_THAN  { o = ExprBinary.BINOP_LT; }
			| LESS_EQUAL { o = ExprBinary.BINOP_LE; }
			| MORE_THAN  { o = ExprBinary.BINOP_GT; }
			| MORE_EQUAL { o = ExprBinary.BINOP_GE; }
			| DOTLT { fname="op.<";  o = ExprBinary.BINOP_LT; }
			| DOTGT { fname="op.<"; o = ExprBinary.BINOP_GT; }
			| DOTLTE { fname="op.<"; o = ExprBinary.BINOP_LE; }
			| DOTGTE { fname="op.<"; o = ExprBinary.BINOP_GE; }
			)
			r = shiftExpr
			{
			   if(fname == null){
			   x = new ExprBinary(o, x, r);
			   }else{
			   	switch(o){
			   		case ExprBinary.BINOP_LT: x = new ExprFunCall(x, fname, x, r); break;
			   		case ExprBinary.BINOP_GT: x = new ExprFunCall(x, fname, r, x); break;
			   		case ExprBinary.BINOP_LE: x = new ExprUnary(x, ExprUnary.UNOP_NOT, new ExprFunCall(x, fname, r, x)); break;
			   		case ExprBinary.BINOP_GE: x = new ExprUnary(x, ExprUnary.UNOP_NOT, new ExprFunCall(x, fname, x, r)); break;
			   	}
			   } 			
			}
		)*
	;

shiftExpr returns [Expression x] { x=null; Expression r; int op=0; }
    :   x=addExpr
        (   ( LSHIFT {op=ExprBinary.BINOP_LSHIFT;}
            | RSHIFT {op=ExprBinary.BINOP_RSHIFT;}
            )
            r=addExpr
            { x = new ExprBinary(op, x, r); }
        )*
    ;

addExpr returns [Expression x] { x = null; Expression r; int o = 0; String fname=null; }
	:	x=multExpr
		(	( PLUS  { o = ExprBinary.BINOP_ADD; }
			| MINUS { o = ExprBinary.BINOP_SUB; }
			| SELECT { o = ExprBinary.BINOP_SELECT; }
			| DOTPLUS { fname = "op.+"; }
			| DOTMINUS { fname = "op.-"; }
			)
			r=multExpr
			{ x = fname == null ? new ExprBinary(o, x, r) : new ExprFunCall(x, fname, x, r) ; }
		)*
	;

multExpr returns [Expression x] { x = null; Expression r; int o = 0; String fname = null;}
	:	x=prefix_expr
		(	( STAR { o = ExprBinary.BINOP_MUL; }
			| DIV  { o = ExprBinary.BINOP_DIV; }
			| MOD  { o = ExprBinary.BINOP_MOD; }
			| DOTTIMES { fname = "op.*"; }
			| DOTDIV { fname = "op./"; }
			| DOTMOD { fname = "op./"; }
			)
			r=prefix_expr
			{ x = fname == null ? new ExprBinary(o, x, r) : new ExprFunCall(x, fname, x, r) ; }
		)*
	;
	
prefix_expr returns [Expression x] { x = null;  FEContext cx = null; int untype = -1;}
	:
	(castExpr) => x = castExpr
	| x = postfix_expr
	| (	  ii:INCREMENT
			{ untype = ExprUnary.UNOP_PREINC; cx = getContext(ii); }
		|  dd:DECREMENT
			{ untype = ExprUnary.UNOP_PREDEC; cx = getContext(dd); }
		|  b:BANG {untype = ExprUnary.UNOP_NOT; cx = getContext(b);} 
	    |  m:MINUS {untype = ExprUnary.UNOP_NEG; cx = getContext(m);} 
		) x = prefix_expr { if(untype != -1){ x = new ExprUnary(cx, untype, x); } }	
	;

prefix_expr_nominus returns [Expression x] { x = null;  FEContext cx = null; int untype = -1;}
	: 
	(castExpr) => x = castExpr
	|	x = postfix_expr
	| (	  ii:INCREMENT
			{ untype = ExprUnary.UNOP_PREINC; cx = getContext(ii); }
		|  dd:DECREMENT
			{ untype = ExprUnary.UNOP_PREDEC; cx = getContext(dd); }
		|  b:BANG {untype = ExprUnary.UNOP_NOT; cx = getContext(b);}  
		) x = prefix_expr { if(untype != -1){ x = new ExprUnary(cx, untype, x); } }	
	;
	
castExpr returns [Expression x] { x = null; Type t = null; Expression bound = null; }
    :   l:LPAREN t=data_type
        RPAREN
        x=prefix_expr_nominus
            { x = new ExprTypeCast(getContext(l), t, x); }
    ;

postfix_expr returns [Expression x] { x = null;  int untype = -1;}
	: x = primary_expr 
	   (	  ii:INCREMENT
			{ x = new ExprUnary(getContext(ii), ExprUnary.UNOP_POSTINC, x); }
		|  dd:DECREMENT
			{ x = new ExprUnary(getContext(dd), ExprUnary.UNOP_POSTDEC, x); })*
	;


primary_expr returns [Expression x] { x = null; Vector<ExprArrayRange.RangeLen> rl;Type t = null; }
	:	x=tminic_value_expr
		(	DOT  ( field:ID 			{ x = new ExprField(x, x, field.getText(), false); } | NDVAL2 { x= new ExprField(x,x,"", true);} | LCURLY t = data_type  {x = new ExprFieldsListMacro(x, x, t);} RCURLY)
		|	l:LSQUARE
					rl=array_range { x = new ExprArrayRange(x, x, rl); }
			RSQUARE
		)*
	;


tminic_value_expr returns [Expression x] { x = null; }
	:	LPAREN x=right_expr RPAREN
	|   (expr_get) => x = expr_get
	|	(func_call) => x=func_call
	| 	(constructor_expr) => x = constructor_expr	
	|	x=var_expr
	|	x=constantExpr
	|   x=arr_initializer
    |   r:REGEN
            { x = new ExprRegen (getContext (r), r.getText ()); }
	;


constructor_expr returns [Expression x] { x = null; TypeStructRef t=null; List l; boolean hole = false; List<Type> tp = null;}
	: n:TK_new
	(prefix:ID AT)? (id:ID { t = new TypeStructRef(prefix != null ? (prefix.getText() + "@" + id.getText() )  : id.getText(), false); } | NDVAL2{hole = true;})
	( tp = type_params_use )?
	l=constr_params { if(tp!= null){ t.addParams(tp); }  x = new ExprNew( getContext(n), t, l, hole);     }
	| BITWISE_OR 
    (prefix2:ID AT)? id2:ID { t = new TypeStructRef(prefix2 != null ? (prefix2.getText() + "@" + id2.getText() )  : id2.getText(), true); }
      BITWISE_OR l=constr_params { if(tp!= null){ t.addParams(tp); } x = new ExprNew( getContext(id2), t, l, hole);     }
	;

var_expr returns [Expression x] { x = null; List rlist; }
:	name:ID { x = new ExprVar(getContext(name), name.getText()); }
	;
	
/*
value returns [Expression x] { x = null; List rlist; }
	:	name:ID { x = new ExprVar(getContext(name), name.getText()); }
		(	DOT field:ID 			{ x = new ExprField(x, x, field.getText()); }
		|	l:LSQUARE
					rlist=array_range_list { x = new ExprArrayRange(x, rlist); }
			RSQUARE
		)*
	;
*/

array_range returns [Vector<ExprArrayRange.RangeLen> x] { x=null; Expression start,end,l; }
    : start=expr_named_param {
        assert (!(start instanceof ExprNamedParam));
        x = new Vector<ExprArrayRange.RangeLen>();
        x.add(new ExprArrayRange.RangeLen(start));
      }
        ( COMMA start=expr_named_param { x.add(new ExprArrayRange.RangeLen(start)); } )*
        (COLON
		  ( end=right_expr {
		  		assert x.size() == 1 : "cannot mix comma indices and array ranges yet";
		  		x.set(0, new ExprArrayRange.RangeLen(start,
		  			new ExprBinary(end, "-", start))); }
		    | COLON
		    l=right_expr {
		    	assert x.size() == 1 : "cannot mix comma indices and array ranges yet";
		    	x.set(0, new ExprArrayRange.RangeLen(start,l)); }
		  )
		)?
    ;

constantExpr returns [Expression x] { x = null; Expression n1=null, n2=null;}
	:	h:HQUAN
			{  String tmp = h.getText().substring(2);
			   Integer iti = new Integer(
	 (int ) ( ( Long.parseLong(tmp, 16) - (long) Integer.MIN_VALUE )
		  % ( (long)Integer.MAX_VALUE - (long) Integer.MIN_VALUE + 1)
		  + Integer.MIN_VALUE) );
				x = ExprConstant.createConstant(getContext(h), iti.toString() ); }
	| 	n:NUMBER
			{ x = ExprConstant.createConstant(getContext(n), n.getText()); }
	|	c:CHAR_LITERAL
			{ x = ExprConstChar.create(c.getText()); }
	|	s:STRING_LITERAL
			{ x = new ExprArrayInit(getContext(s), ExprConstChar.createFromString(s.getText())); }
	|	t:TK_true
			{ x = ExprConstInt.one; }
	|	f:TK_false
			{ x = ExprConstInt.zero; }
	|   TK_null
			{ x = ExprNullPtr.nullPtr; }
    |   t1:NDVAL
            { x = new ExprStar(getContext(t1)); }
    |   t2:NDVAL2 (LPAREN n1=addExpr (COMMA n2=addExpr)? RPAREN)?
            {  if(n1 != null){
            	Integer in1 = n1.getIValue();
            	  if(n2 == null){            	  	
            	  	x = new ExprStar(getContext(t2),in1);
            	  }else{
            	  	Integer in2 = n2.getIValue();
            	  	x = new ExprStar(getContext(t2),in1, in2);
            	  } 
            	}else{
            	  x = new ExprStar(getContext(t2)); 
            	}
            }
    |	t3:NDANGELIC
			{x = new ExprStar(getContext(t3), Kind.ANGELIC); }
    |  (local_variable) => x = local_variable
    ;
    
local_variable returns [Expression localVariable] {
	localVariable = null;
	Type type = null;
}
	: 	context:DOLLAR // $ 
		LPAREN 
		type = data_type 
		RPAREN
            {
              localVariable = new ExprLocalVariables(getContext(context), type); 
            }
     ;

adt_decl returns [List<StructDef> adtList]
{ adtList = new ArrayList<StructDef>(); List<StructDef> innerList; 
  StructDef str = null; Parameter p; List names = new ArrayList();
  Annotation an = null; StructDef innerStruct;
  List<String> typeargs = new ArrayList<String>();
  HashmapList<String, Annotation> annotations = new HashmapList<String, Annotation>();
  List types = new ArrayList(); 
  FEContext fec = null;
  }

	:  t:TK_adt id:ID { fec = getContext(t); StreamItLex.lastComment = null;  }
	(
		LESS_THAN
		  typearg : ID {typeargs.add(typearg.getText());}
		  (COMMA moretypearg : ID { typeargs.add(moretypearg.getText()); })*
		MORE_THAN		
		)?
		LCURLY
	(innerList=adt_decl { innerStruct = innerList.get(0); 
						  innerStruct.setParentName(id.getText());
						  innerStruct.setTypeargs(typeargs);
						  adtList.addAll(innerList);}
	| innerStruct=structInsideADT_decl {innerStruct.setParentName(id.getText()); 
										innerStruct.setTypeargs(typeargs);
										adtList.add(innerStruct);}
	| p=param_decl SEMI {names.add(p.getName()); types.add(p.getType());}
	| an=annotation {annotations.append(an.tag, an);}
	)*
	RCURLY
	{str = StructDef.creator(fec, id.getText(), null, adtList.isEmpty(), names, types, typeargs, annotations).create();
     str.setImmutable();
	 adtList.add(0, str);
	}
	;
structInsideADT_decl returns [StructDef ts]
{ ts = null; Parameter p; List names = new ArrayList();
	Annotation an=null;
	List<String> typeargs = new ArrayList<String>();
	HashmapList<String, Annotation> annotations = new HashmapList<String, Annotation>();
	List types = new ArrayList(); }
	:	id:ID
		
		LCURLY
		(p=param_decl SEMI
			{ names.add(p.getName()); types.add(p.getType()); }
			|
			an=annotation{ annotations.append(an.tag, an); }
		)*
		RCURLY
		{ 
			ts = StructDef.creator(getContext(id), id.getText(),null, true, names, types, typeargs, annotations).create();
			StreamItLex.lastComment = null;
			}
	;
struct_decl returns [StructDef ts]
{ ts = null; Parameter p; List names = new ArrayList();
	Annotation an=null;
	List<String> typeargs = new ArrayList<String>();
	HashmapList<String, Annotation> annotations = new HashmapList<String, Annotation>();
	List types = new ArrayList(); 
	FEContext fec = null;
	}
	:	(an=annotation{ annotations.append(an.tag, an); })*
	t:TK_struct id:ID { fec = getContext(t); StreamItLex.lastComment = null; }
		(
		LESS_THAN
		  typearg : ID {typeargs.add(typearg.getText());}
		  (COMMA moretypearg : ID { typeargs.add(moretypearg.getText()); })*
		MORE_THAN		
		)?
		//ADT
		(TK_extends parent:ID 
		{
			parentStructNames.add(parent.getText());
		}
		)?
		LCURLY
		(p=param_decl SEMI
			{ names.add(p.getName()); types.add(p.getType()); }
			|
			an=annotation{ annotations.append(an.tag, an); }
		)*
		RCURLY
		{ 
			if(parent != null) {
				ts = StructDef.creator(fec, id.getText(),parent.getText(), true, names, types, typeargs, annotations).create();
			}else{
				ts = StructDef.creator(fec, id.getText(),null, true, names, types, typeargs, annotations).create();
			} }
	;